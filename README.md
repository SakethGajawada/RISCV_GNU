# RISCV_GNU
## Testing
* Open a terminal window.
* Navigate to the directory containing the sample.c file.
* Design a function that executes the intended logic you require.
* Compile the code using the GCC compiler and verify the output:
```
gcc sample.c
./a.out
```
## RISCV GNU Toolchain Installation

Refer [RISCV-GNU-Toolchain](https://github.com/riscv-collab/riscv-gnu-toolchain).


## Assembly Code Generation
### Note : Comment print statements while running the below commands
Run the below command to compile using RISC-V GNU Toolchain
```
riscv32-unknown-elf-gcc -c -mabi=ilp32 -march=rv32im -ffreestanding -o ./sample sample.c
```

Run the below command to generate assembly instructions file for the function created in the sample.c .
```
riscv32-unknown-elf-objdump -d sample.c --disassemble=newlogicÂ  > sample_assembly.txt
```

## Assembly Instruction Counter
### Overview
The Assembly Instruction Counter is a Python script designed to analyze RISC-V assembly code files generated by the RISC-V GNU toolchain. It counts the number of different instructions used in the code and lists those instructions. This tool can be helpful in understanding the diversity of instructions within your assembly code.

### Usage
* Prerequisites: Ensure you have Python installed on your system.

* Download: Place the line_follower.txt assembly code file in the same directory as the Python script (instruction_counter.py).

* Run the Script: Open a terminal or command prompt and navigate to the directory containing the script and the assembly code file. Run the following command:

```
python instruction_counter.py
```
* Number of different instructions used.
The script will process the assembly code file and display the number of different instructions used along with a list of those instructions.
### Notes
* The script starts analyzing the assembly code from the sixth line of the file, excluding file format and section information.
* It ignores empty lines and lines beginning with '#' (comments).
* The script extracts the third part (instruction) from each line, assuming a consistent structure with at least three parts per line.
* The output provides the count and a list of unique instructions used in the assembly code.

Feel free to modify the script to suit your specific requirements or contribute to its development.
# CustomCore Tool


https://github.com/SakethGajawada/RISCV_GNU/assets/77500278/b7fba62f-f9fc-4ebd-8447-a8cbbba7ca44



## Example - 1
## Sample code gcc output

```
output1 = 3
output2 = 3
```
## Assembly code conversion 

Compile the c program using RISCV-V GNU Toolchain and dump the assembly code into sample_assembly.txt using the above commands

### Contents of assemlby.txt
```

sample:     file format elf32-littleriscv


Disassembly of section .text:

00000000 <newlogic>:
   0:	fd010113          	addi	sp,sp,-48
   4:	02812623          	sw	s0,44(sp)
   8:	03010413          	addi	s0,sp,48
   c:	fea42623          	sw	a0,-20(s0)
  10:	feb42423          	sw	a1,-24(s0)
  14:	fec42223          	sw	a2,-28(s0)
  18:	fed42023          	sw	a3,-32(s0)
  1c:	fce42e23          	sw	a4,-36(s0)
  20:	fec42703          	lw	a4,-20(s0)
  24:	fe842783          	lw	a5,-24(s0)
  28:	00f77733          	and	a4,a4,a5
  2c:	fe442783          	lw	a5,-28(s0)
  30:	00f76733          	or	a4,a4,a5
  34:	fe042783          	lw	a5,-32(s0)
  38:	00e7a023          	sw	a4,0(a5)
  3c:	fec42703          	lw	a4,-20(s0)
  40:	fe842783          	lw	a5,-24(s0)
  44:	00f76733          	or	a4,a4,a5
  48:	fdc42783          	lw	a5,-36(s0)
  4c:	00e7a023          	sw	a4,0(a5)
  50:	00000013          	nop
  54:	02c12403          	lw	s0,44(sp)
  58:	03010113          	addi	sp,sp,48
  5c:	00008067          	ret
```
Suppose your assembly code contains instructions like addi, lw, sw, and so on. 
Running the instruction_counter.py on this sample_assembly.txt would yield:
```
Number of different instructions: 7
List of unique instructions:
ret
lw
and
addi
nop
sw
or
```


## Example - 2 Linefollower
## Demo

https://github.com/SakethGajawada/RISCV_GNU/assets/77500278/96e2a529-00f5-453e-82ce-b59a312b8721

## Linefollower
<img src="https://github.com/SakethGajawada/RISCV_GNU/blob/main/Images/line_follower_image.jpg" alt="Line follower" style="max-width: 30%;" />


## Block Diagram 
<img src="https://github.com/SakethGajawada/RISCV_GNU/blob/main/Images/Flowchart.png" alt="Flowchart" style="max-width: 30%;" />


## C Code

```
//assuming sensors gives 1 if it detcts white
//sensors to detect line :     0 : right  ,  1  :  left
//gpio's for motors operating vehicle     3 : right_front  ,  4  :  right_back  ,  5  :  left_front,   6  :  left_back 
void line_follower(int i_r,int i_l,int* o_rf,int* o_rb,int* o_lf,int*o_lb){
    if((!i_r) && (!i_l)){
        o_rf = 1;o_rb=0;o_lf=1;o_lb=0;
    }
    else if((!i_r) && (i_l)){
        o_rf = 1;o_rb=0;o_lf=0;o_lb=1;
    }
    else if((!i_l) && (i_r)) {
        o_rf = 0;o_rb=1;o_lf=1;o_lb=0;
    }
    else {
        o_rf = 0;o_rb=0;o_lf=0;o_lb=0;
    }
}
```

## Assembly code conversion 
Compile the c program using RISCV-V GNU Toolchain and dump the assembly code into sample_assembly.txt using the above commands.
## Note 
In the above c program, digital read and digital write functions are commented to show how the inputs and outputs are given. For now, we need only the logic which controls the linefollower robot.
### Contents of assemlby.txt
```

line_follower:     file format elf32-littleriscv


Disassembly of section .text:

00000000 <line_follower>:
   0:	fd010113          	addi	sp,sp,-48
   4:	02812623          	sw	s0,44(sp)
   8:	03010413          	addi	s0,sp,48
   c:	fea42623          	sw	a0,-20(s0)
  10:	feb42423          	sw	a1,-24(s0)
  14:	fec42223          	sw	a2,-28(s0)
  18:	fed42023          	sw	a3,-32(s0)
  1c:	fce42e23          	sw	a4,-36(s0)
  20:	fcf42c23          	sw	a5,-40(s0)
  24:	fec42783          	lw	a5,-20(s0)
  28:	02079c63          	bnez	a5,60 <.L2>
  2c:	fe842783          	lw	a5,-24(s0)
  30:	02079863          	bnez	a5,60 <.L2>
  34:	fe442783          	lw	a5,-28(s0)
  38:	00100713          	li	a4,1
  3c:	00e7a023          	sw	a4,0(a5)
  40:	fe042783          	lw	a5,-32(s0)
  44:	0007a023          	sw	zero,0(a5)
  48:	fdc42783          	lw	a5,-36(s0)
  4c:	00100713          	li	a4,1
  50:	00e7a023          	sw	a4,0(a5)
  54:	fd842783          	lw	a5,-40(s0)
  58:	0007a023          	sw	zero,0(a5)
  5c:	0a00006f          	j	fc <.L3>

00000060 <.L2>:
  60:	fec42783          	lw	a5,-20(s0)
  64:	02079c63          	bnez	a5,9c <.L4>
  68:	fe842783          	lw	a5,-24(s0)
  6c:	02078863          	beqz	a5,9c <.L4>
  70:	fe442783          	lw	a5,-28(s0)
  74:	00100713          	li	a4,1
  78:	00e7a023          	sw	a4,0(a5)
  7c:	fe042783          	lw	a5,-32(s0)
  80:	0007a023          	sw	zero,0(a5)
  84:	fdc42783          	lw	a5,-36(s0)
  88:	0007a023          	sw	zero,0(a5)
  8c:	fd842783          	lw	a5,-40(s0)
  90:	00100713          	li	a4,1
  94:	00e7a023          	sw	a4,0(a5)
  98:	0640006f          	j	fc <.L3>

0000009c <.L4>:
  9c:	fe842783          	lw	a5,-24(s0)
  a0:	02079c63          	bnez	a5,d8 <.L5>
  a4:	fec42783          	lw	a5,-20(s0)
  a8:	02078863          	beqz	a5,d8 <.L5>
  ac:	fe442783          	lw	a5,-28(s0)
  b0:	0007a023          	sw	zero,0(a5)
  b4:	fe042783          	lw	a5,-32(s0)
  b8:	00100713          	li	a4,1
  bc:	00e7a023          	sw	a4,0(a5)
  c0:	fdc42783          	lw	a5,-36(s0)
  c4:	00100713          	li	a4,1
  c8:	00e7a023          	sw	a4,0(a5)
  cc:	fd842783          	lw	a5,-40(s0)
  d0:	0007a023          	sw	zero,0(a5)
  d4:	0280006f          	j	fc <.L3>

000000d8 <.L5>:
  d8:	fe442783          	lw	a5,-28(s0)
  dc:	0007a023          	sw	zero,0(a5)
  e0:	fe042783          	lw	a5,-32(s0)
  e4:	0007a023          	sw	zero,0(a5)
  e8:	fdc42783          	lw	a5,-36(s0)
  ec:	0007a023          	sw	zero,0(a5)
  f0:	fd842783          	lw	a5,-40(s0)
  f4:	0007a023          	sw	zero,0(a5)
  f8:	00000013          	nop

000000fc <.L3>:
  fc:	00000013          	nop
 100:	02c12403          	lw	s0,44(sp)
 104:	03010113          	addi	sp,sp,48
 108:	00008067          	ret
```
Suppose your assembly code contains instructions like addi, lw, sw, and so on. 
Running the instruction_counter.py on this sample_assembly.txt would yield:
```
Number of different instructions: 9
List of unique instructions:
li
sw
addi
beqz
lw
bnez
nop
ret
j
```
