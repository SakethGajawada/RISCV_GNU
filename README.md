# RISCV_GNU
## Testing
* Open a terminal window.
* Navigate to the directory containing the sample.c file.
* Design a function that executes the intended logic you require.
* Compile the code using the GCC compiler and verify the output:
```
gcc sample.c
./a.out
```
## RISCV GNU Toolchain Installation

Refer [RISCV-GNU-Toolchain](https://github.com/riscv-collab/riscv-gnu-toolchain).


## Assembly Code Generation
### Note : Comment print statements while running the below commands
Run the below command to compile using RISC-V GNU Toolchain
```
riscv32-unknown-elf-gcc -c -mabi=ilp32 -march=rv32im -ffreestanding -o ./sample sample.c
```

Run the below command to generate assembly instructions file for the function created in the sample.c .
```
riscv32-unknown-elf-objdump -d sample.c --disassemble=newlogicÂ  > sample_assembly.txt
```

## Assembly Instruction Counter
### Overview
The Assembly Instruction Counter is a Python script designed to analyze RISC-V assembly code files generated by the RISC-V GNU toolchain. It counts the number of different instructions used in the code and lists those instructions. This tool can be helpful in understanding the diversity of instructions within your assembly code.

### Usage
* Prerequisites: Ensure you have Python installed on your system.

* Download: Place the line_follower.txt assembly code file in the same directory as the Python script (instruction_counter.py).

* Run the Script: Open a terminal or command prompt and navigate to the directory containing the script and the assembly code file. Run the following command:

```
python instruction_counter.py
```
* Number of different instructions used.
The script will process the assembly code file and display the number of different instructions used along with a list of those instructions.
### Notes
* The script starts analyzing the assembly code from the sixth line of the file, excluding file format and section information.
* It ignores empty lines and lines beginning with '#' (comments).
* The script extracts the third part (instruction) from each line, assuming a consistent structure with at least three parts per line.
* The output provides the count and a list of unique instructions used in the assembly code.

Feel free to modify the script to suit your specific requirements or contribute to its development.

## Example
## Sample code gcc output

```
output1 = 3
output2 = 3
```
## Assembly code conversion 

Compile the c program usingRISCV-V GNU Toolchain and dump the assembly code into sample+assembly.txt using the above commands

### Contents of assemlby.txt
```

sample:     file format elf32-littleriscv


Disassembly of section .text:

00000000 <newlogic>:
   0:	fd010113          	addi	sp,sp,-48
   4:	02812623          	sw	s0,44(sp)
   8:	03010413          	addi	s0,sp,48
   c:	fea42623          	sw	a0,-20(s0)
  10:	feb42423          	sw	a1,-24(s0)
  14:	fec42223          	sw	a2,-28(s0)
  18:	fed42023          	sw	a3,-32(s0)
  1c:	fce42e23          	sw	a4,-36(s0)
  20:	fec42703          	lw	a4,-20(s0)
  24:	fe842783          	lw	a5,-24(s0)
  28:	00f77733          	and	a4,a4,a5
  2c:	fe442783          	lw	a5,-28(s0)
  30:	00f76733          	or	a4,a4,a5
  34:	fe042783          	lw	a5,-32(s0)
  38:	00e7a023          	sw	a4,0(a5)
  3c:	fec42703          	lw	a4,-20(s0)
  40:	fe842783          	lw	a5,-24(s0)
  44:	00f76733          	or	a4,a4,a5
  48:	fdc42783          	lw	a5,-36(s0)
  4c:	00e7a023          	sw	a4,0(a5)
  50:	00000013          	nop
  54:	02c12403          	lw	s0,44(sp)
  58:	03010113          	addi	sp,sp,48
  5c:	00008067          	ret
```
Suppose your assembly code contains instructions like addi, lw, sw, and so on. 
Running the instruction_counter.py on this sample_assembly.txt would yield:
```
Number of different instructions: 7
List of unique instructions:
ret
lw
and
addi
nop
sw
or
```
